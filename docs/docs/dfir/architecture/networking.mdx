---
sidebar_position: 3
---
import CodeBlock from '@theme/CodeBlock';
import echoServerCode from '!!raw-loader!../../../../dfir_rs/examples/echo_server/server.rs';
import tcpEchoServerCode from '!!raw-loader!../../../../dfir_rs/examples/echo_server_tcp/main.rs';
import httpServerCode from '!!raw-loader!../../../../dfir_rs/examples/http_server/server.rs';
import httpClientCode from '!!raw-loader!../../../../dfir_rs/examples/http_server/client.rs';
import websocketChatServerCode from '!!raw-loader!../../../../dfir_rs/examples/chat_websocket/server.rs';
import websocketChatClientCode from '!!raw-loader!../../../../dfir_rs/examples/chat_websocket/client.rs';
import websocketEchoServerCode from '!!raw-loader!../../../../dfir_rs/examples/echo_server_websocket/main.rs';
import { getLines } from '../../../src/util';

# Networking with DFIR

DFIR provides comprehensive networking support for building distributed systems that process data streams over UDP, TCP, HTTP, and WebSocket protocols. This guide covers the fundamental networking patterns and demonstrates how to build servers and clients using DFIR's declarative dataflow programming model.

## Overview

DFIR's networking model follows these key principles:

- **Stream-oriented**: Network data flows as streams through DFIR operators
- **Dataflow Programming**: Network logic is expressed as dataflow graphs
- **Protocol-agnostic**: Similar patterns work across UDP, TCP, HTTP, and WebSocket
- **Error-aware**: Built-in error handling with demux routing
- **Address-aware**: All network operations include source/destination addressing

## Core Networking Patterns

### Basic Server Pattern

Nearly all DFIR network servers follow this pattern:

```
bind_protocol();
source_stream() -> demux() -> processing -> dest_sink()
```

### Basic Client Pattern

Most DFIR network clients follow this pattern:

```
connect_protocol();
source_stream() -> demux() -> processing
```

## UDP Networking

UDP provides connectionless, best-effort message delivery. DFIR's UDP support is ideal for high-throughput, low-latency applications.

### UDP Echo Server

**Source:** [dfir_rs/examples/echo_server/server.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server/server.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(echoServerCode, 'imports')}</CodeBlock>

UDP servers start by binding to a socket address to create the inbound and outbound streams:

<CodeBlock language="rust" showLineNumbers>{getLines(echoServerCode, 'bind_udp')}</CodeBlock>

The UDP echo server demonstrates the fundamental DFIR networking pattern:

<CodeBlock language="rust" showLineNumbers>{getLines(echoServerCode, 'dfir_flow')}</CodeBlock>

Finally, compile and run the DFIR graph:

<CodeBlock language="rust" showLineNumbers>{getLines(echoServerCode, 'run_server')}</CodeBlock>

Key UDP characteristics:
- **Connectionless**: Each message is independent
- **Best-effort**: No delivery guarantees
- **Low overhead**: Minimal protocol overhead
- **High throughput**: Suitable for streaming data

**Testing:** See [dfir_rs/examples/echo_server/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server/README.md) for instructions on running and testing this example.

## TCP Networking

TCP provides reliable, connection-oriented byte streams. DFIR's TCP support handles connection management automatically while exposing a stream-based interface.

### TCP Echo Server

**Source:** [dfir_rs/examples/echo_server_tcp/main.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server_tcp/main.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(tcpEchoServerCode, 'imports')}</CodeBlock>

#### LocalSet Requirement for TCP Operations

TCP operations in DFIR require the use of tokio's `LocalSet` for specific parts of your application. You don't need to restructure your entire application around LocalSet - you can use it selectively for TCP operations.

**What is LocalSet?**
- LocalSet is a tokio utility that provides a single-threaded execution context for async tasks
- Unlike regular tokio tasks that can run on any thread in the runtime's thread pool, LocalSet tasks are guaranteed to run on the same thread
- This is required because DFIR's TCP implementation uses `spawn_local` internally

**Why TCP needs LocalSet:**
- DFIR's `bind_tcp_bytes`, `bind_tcp_lines`, and related TCP functions use `spawn_local` internally
- `spawn_local` requires being called from within a LocalSet context
- This design choice ensures proper connection state management and thread safety

**Practical Usage Pattern:**
You can use a regular `#[tokio::main]` and wrap only the TCP operations in LocalSet:

<CodeBlock language="rust" showLineNumbers>{getLines(tcpEchoServerCode, 'bind_tcp')}</CodeBlock>

The TCP server processes connection streams through DFIR:

<CodeBlock language="rust" showLineNumbers>{getLines(tcpEchoServerCode, 'dfir_flow')}</CodeBlock>

Finally, compile and run the DFIR graph within the LocalSet context:

<CodeBlock language="rust" showLineNumbers>{getLines(tcpEchoServerCode, 'run_server')}</CodeBlock>

Key TCP characteristics:
- **Connection-oriented**: Explicit connection establishment
- **Reliable**: Guaranteed in-order delivery
- **Flow control**: Automatic congestion management
- **Stateful**: Connection state maintained automatically

**Testing:** See [dfir_rs/examples/echo_server_tcp/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server_tcp/README.md) for instructions on running and testing this example.

## HTTP Networking

HTTP builds on TCP to provide request-response semantics with rich metadata. DFIR's HTTP support includes request/response parsing and routing.

**Note:** Like TCP operations, HTTP operations in DFIR also require `LocalSet` for the binding and execution phases since they use the underlying TCP infrastructure. You can use the same selective LocalSet pattern as with TCP.

### HTTP Server

**Source:** [dfir_rs/examples/http_server/server.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/http_server/server.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'imports')}</CodeBlock>

HTTP servers bind to addresses and receive structured requests. Use LocalSet for HTTP operations:

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'bind_server')}</CodeBlock>

HTTP request routing uses demux for efficient path-based dispatch:

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'route_handlers')}</CodeBlock>

Response generation follows the same patterns:

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'response_union')}</CodeBlock>

Finally, run the DFIR graph:

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'run_server')}</CodeBlock>

**Testing:** See [dfir_rs/examples/http_server/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/http_server/README.md) for instructions on running and testing this example.

### HTTP Client

**Source:** [dfir_rs/examples/http_server/client.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/http_server/client.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(httpClientCode, 'imports')}</CodeBlock>

HTTP clients connect and send structured requests. Like servers, clients also require LocalSet:

<CodeBlock language="rust" showLineNumbers>{getLines(httpClientCode, 'connect_client')}</CodeBlock>

Client request processing:

<CodeBlock language="rust" showLineNumbers>{getLines(httpClientCode, 'send_requests')}</CodeBlock>

Response handling with error processing:

<CodeBlock language="rust" showLineNumbers>{getLines(httpClientCode, 'response_processing')}</CodeBlock>

Key HTTP characteristics:
- **Request-response**: Structured message exchange
- **Stateless**: Each request is independent
- **Rich metadata**: Headers, methods, status codes
- **Content-aware**: Body parsing and generation

**Testing:** See [dfir_rs/examples/http_server/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/http_server/README.md) for instructions on running and testing both the server and client examples.

## WebSocket Networking

WebSockets provide full-duplex communication over TCP with HTTP upgrade handshake. DFIR's WebSocket support enables real-time bidirectional messaging with automatic connection management and frame handling.

**Note:** Like TCP and HTTP operations, WebSocket operations in DFIR also require `LocalSet` since they use the underlying TCP infrastructure for connection management.

### WebSocket Chat Server

**Source:** [dfir_rs/examples/chat_websocket/server.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/chat_websocket/server.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(websocketChatServerCode, 'imports')}</CodeBlock>

WebSocket servers bind to addresses and automatically handle the HTTP upgrade handshake:

<CodeBlock language="rust" showLineNumbers>{getLines(websocketChatServerCode, 'bind_websocket')}</CodeBlock>

The WebSocket chat server demonstrates message broadcasting and command processing:

<CodeBlock language="rust" showLineNumbers>{getLines(websocketChatServerCode, 'dfir_flow')}</CodeBlock>

Key WebSocket characteristics:
- **Full-duplex**: Bidirectional real-time communication
- **Frame-based**: Structured message types (Text, Binary, Ping, Pong, Close)
- **Connection-oriented**: Persistent connections with state management
- **HTTP upgrade**: Starts as HTTP then upgrades to WebSocket protocol

**Testing:** See [dfir_rs/examples/chat_websocket/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/chat_websocket/README.md) for instructions on running and testing this example.

### WebSocket Echo Server

**Source:** [dfir_rs/examples/echo_server_websocket/main.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server_websocket/main.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(websocketEchoServerCode, 'imports')}</CodeBlock>

A simpler WebSocket server that echoes messages back to clients:

<CodeBlock language="rust" showLineNumbers>{getLines(websocketEchoServerCode, 'bind_websocket')}</CodeBlock>

The echo server handles different WebSocket message types:

<CodeBlock language="rust" showLineNumbers>{getLines(websocketEchoServerCode, 'dfir_flow')}</CodeBlock>

**Testing:** See [dfir_rs/examples/echo_server_websocket/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server_websocket/README.md) for instructions on running and testing this example.

### WebSocket Client

**Source:** [dfir_rs/examples/chat_websocket/client.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/chat_websocket/client.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(websocketChatClientCode, 'imports')}</CodeBlock>

WebSocket clients connect to servers and can send/receive messages:

<CodeBlock language="rust" showLineNumbers>{getLines(websocketChatClientCode, 'connect_websocket')}</CodeBlock>

Client message processing with automatic connection handling:

<CodeBlock language="rust" showLineNumbers>{getLines(websocketChatClientCode, 'dfir_flow')}</CodeBlock>

### WebSocket Message Types

DFIR WebSocket support includes all standard WebSocket frame types:

```rust
// WebSocket message types
enum WebSocketMessage {
    Text(String),           // UTF-8 text messages
    Binary(Vec<u8>),        // Binary data messages  
    Ping(Vec<u8>),          // Ping frames for keepalive
    Pong(Vec<u8>),          // Pong responses
    Close(CloseFrame),      // Connection close frames
}
```

### WebSocket Error Handling

WebSocket operations use consistent error handling with the networking stack:

```rust
// WebSocket error handling
messages = source_stream(websocket_recv)
    -> map(|result| {
        match result {
            Ok((msg, client_addr)) => {
                println!("Received from {}: {:?}", client_addr, msg);
                Some((msg, client_addr))
            }
            Err(e) => {
                eprintln!("WebSocket error: {:?}", e);
                None
            }
        }
    })
    -> filter_map(|x| x);
```

## Error Handling

All DFIR networking uses consistent error handling patterns with demux:

```rust
// UDP error handling
messages = source_stream(socket_recv)
    -> demux(|result, var_args!(success, error)| {
        match result {
            Ok((data, addr)) => success.give((data, addr)),
            Err(e) => error.give(e),
        }
    });

messages[success] -> /* process valid messages */;
messages[error] -> for_each(|e| eprintln!("Error: {}", e));
```

## Address Management

DFIR networking operators always include address information:

- **UDP**: `(data, SocketAddr)` tuples for each packet
- **TCP**: `(data, SocketAddr)` tuples identifying the connection
- **HTTP**: `(HttpRequest/Response, SocketAddr)` tuples with client info
- **WebSocket**: `(WebSocketMessage, SocketAddr)` tuples with client connection info

## Performance Considerations

### UDP Performance
- Use `bind_udp_bytes()` for maximum throughput
- Consider message size vs. fragmentation
- Implement application-level reliability if needed

### TCP Performance
- Connection reuse is handled automatically
- Use appropriate buffer sizes for your workload
- Consider connection pooling for high-concurrency clients

### HTTP Performance
- Leverage HTTP keep-alive for connection reuse
- Use appropriate content encoding
- Consider HTTP/2 for multiplexing (future enhancement)

### WebSocket Performance
- Persistent connections reduce connection overhead
- Frame types optimize for message content (text vs binary)
- Built-in ping/pong for connection keepalive
- Consider message batching for high-frequency updates

## Advanced Patterns

### Multi-protocol Servers

Single DFIR graphs can handle multiple protocols:

```rust
dfir_syntax! {
    // Combine multiple protocol streams
    udp_messages = source_stream(udp_recv) -> map(tag_udp);
    tcp_messages = source_stream(tcp_recv) -> map(tag_tcp);
    websocket_messages = source_stream(websocket_recv) -> map(tag_websocket);
    
    all_messages = union(udp_messages, tcp_messages, websocket_messages) -> process_unified;
}
```

### Protocol Composition

DFIR's uniform stream model enables protocol composition:

```rust
// HTTP over UDP tunnel
udp_stream -> map(parse_http) -> demux(route_requests) -> map(generate_response) -> udp_sink

// WebSocket message relay
websocket_stream -> map(extract_text) -> tcp_sink
tcp_stream -> map(wrap_websocket) -> websocket_sink
```


### Load Balancing

DFIR's demux operator easily enables writing simple load balancers
based on hashing or the like.

```rust
// Route by client address
requests -> demux(|(req, addr), var_args!(server1, server2, server3)| {
    match addr.ip().octets()[3] % 3 {
        0 => server1.give((req, addr)),
        1 => server2.give((req, addr)),
        _ => server3.give((req, addr)),
    }
});
```
More complex load balancing would be achieved by computing, say,
runtime statistics, and `match`ing on those as in the pattern above.

## Best Practices

1. **Always handle errors**: Use demux to separate success/error paths
2. **Include addresses**: Maintain client addressing throughout processing
3. **Use appropriate protocols**: UDP for throughput, TCP for reliability, HTTP for structure
4. **Consider backpressure**: DFIR handles flow control automatically
5. **Test incrementally**: Start with simple echo servers and add complexity
6. **Monitor performance**: Use DFIR's built-in observability features

## LocalSet Requirements Summary

Understanding when LocalSet is required for DFIR networking:

| Protocol | LocalSet Required | Reason |
|----------|------------------|---------|
| **UDP** | ❌ No | Uses regular tokio tasks and thread-safe operations |
| **TCP** | ✅ Yes | Internal `spawn_local` usage for connection management |
| **HTTP** | ✅ Yes | Built on TCP infrastructure, inherits LocalSet requirement |
| **WebSocket** | ✅ Yes | Built on TCP infrastructure, inherits LocalSet requirement |

**Canonical LocalSet Usage Pattern:**
```rust
use tokio::task::LocalSet;

#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:3000";
    
    // Single LocalSet scope for both binding and execution
    LocalSet::new().run_until(async move {
        // Step 1: Bind within LocalSet (TCP/HTTP/WebSocket)
        let (sink, stream, addr) = dfir_rs::util::bind_tcp_lines(addr).await;
        // or: dfir_rs::util::bind_websocket_server(addr).await;
        
        // Step 2: DFIR graph definition
        let mut flow = dfir_syntax! {
            source_stream(stream) -> dest_sink(sink);
        };
        
        // Step 3: Execute within same LocalSet
        flow.run_async().await;
    }).await;
}
```

**Why this matters:**
- LocalSet is only needed for the specific operations that use TCP/HTTP/WebSocket binding and execution
- You don't need to restructure your entire application around LocalSet
- UDP operations work fine in regular tokio contexts
- TCP/HTTP/WebSocket operations will panic at runtime if not within LocalSet context

This networking foundation enables building sophisticated distributed systems with DFIR's declarative, stream-oriented programming model.
